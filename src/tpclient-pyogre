#! /usr/bin/env python

# Importing requirements automatically checks prerequisites
import requirements

import os
import sys
import time

import ogre.renderer.OGRE as ogre
import ogre.gui.CEGUI as cegui
from tp.client.threads import NetworkThread, MediaThread, FinderThread
from tp.client.threads import Application as ClientApplication
from tp.client.cache import Cache

import framework
import scene
from loadingbar import *

def traceback():
	import sys, traceback, string
	type, val, tb = sys.exc_info()
	sys.stderr.write(string.join(traceback.format_exception(type, val, tb), ''))
	sys.stderr.flush()


class GUI(framework.Application):
	def __init__(self, application):
		framework.Application.__init__(self)
		
		self.application = application
		self.guiRenderer = 0
		self.guiSystem = 0
		self.loading_bar = LoadingBar()

		self.tocall = []
		
		self.screen_hidden = True

	def start(self):
		try:
			self.go()
		finally:
			self.application.Exit()

	def _createScene(self):
		"""Setup CEGUI and create the various scenes"""
		# Initialise CEGUI Renderer
		self.guiRenderer = cegui.OgreCEGUIRenderer(self.renderWindow,
				   ogre.RENDER_QUEUE_OVERLAY, True, 0, self.sceneManager)
		self.guiSystem = cegui.System(self.guiRenderer)
		cegui.Logger.getSingleton().loggingLevel = cegui.Insane

		# Load Cegui Scheme
		cegui.SchemeManager.getSingleton().loadScheme("SleekSpace.scheme")
		self.guiSystem.setDefaultMouseCursor("SleekSpace", "MouseArrow")

		wmgr = cegui.WindowManager.getSingleton()
		root = wmgr.createWindow("DefaultWindow", "root")
		self.guiSystem.setGUISheet(root)

		self.login = scene.LoginScene(self, self.sceneManager)
		self.starmap = scene.StarmapScene(self, self.sceneManager)

		self.guiSystem.injectMousePosition(0, 0)
		self.changeScene(self.login)

		if self.application.url != None:
			self.login.setServer(self.application.url)

	def _createCamera(self):
		self.camera = self.sceneManager.createCamera("PlayerCam")
		self.camera.nearClipDistance = 5
		self.camera.setFixedYawAxis(True, ogre.Vector3.UNIT_Y)

	def _createFrameListener(self):
		self.frameListener = framework.CEGUIFrameListener(self, self.renderWindow, self.camera)
		self.root.addFrameListener(self.frameListener)
		self.frameListener.showDebugOverlay(False)

	def __del__(self):
		"""Clear variables
		
		This is needed to ensure the correct order of deletion.
		
		"""
		del self.camera
		del self.sceneManager
		del self.frameListener
		del self.guiSystem
		del self.guiRenderer
		del self.root
		del self.renderWindow		

	def connectCallback(self, *args, **kw):
		print "gui connect callback", args, kw
		if not self.loading_bar.started:
			self.loading_bar.start(self.renderWindow)
			self.loading_bar.show()
			self.loading_bar.setTitle("Connecting")
		if len(args[0]) == 3:
			self.loading_bar.setCaption(args[0][2])

	def updateCallback(self, *args, **kw):
		print "gui update callback", args, kw
		if not self.loading_bar.started:
			self.loading_bar.start(self.renderWindow)
			self.loading_bar.show()
			self.loading_bar.setTitle("Updating")
		if args[1].has_key('message'):
			self.loading_bar.setCaption(args[1]['message'])
		if args[1].has_key('todownload'):
			groups = args[1]['todownload']
			self.loading_bar.setTitle("Updating %s" % args[0][0])
			if groups > 0:
				self.loading_bar.start(self.renderWindow, groups)
		if args[0][1] == 'downloaded':
			self.loading_bar.advance()

	def loadingFinished(self):
		self.loading_bar.finish()

	def hideScreen(self):
		if not self.screen_hidden:
			self.screen_hidden = True
			self.currentScene.hide()

	def showScreen(self):
		if self.screen_hidden:
			self.screen_hidden = False
			self.currentScene.show()

	def showMessage(self, text):
		if hasattr(self.currentScene, "showMessage"):
			self.currentScene.showMessage(text)
	
	def frameStarted(self, evt):
		if not self.frameListener.keepRendering:
			print "destroying"
			self.frameListener.destroy()
			self.application.Exit()

		if len(self.tocall) <= 0:
			return
			
		method, args, kw = self.tocall.pop(0)
		method(*args, **kw)

	def Call(self, method, *args, **kw):
		"""Call a method in this thread"""
		self.tocall.append((method, args, kw))

	def ConfigLoad(self, config):
		return
	
	def Post(self, event):
		"""Post an Event the current window"""
		func = 'on' + event.__class__.__name__[:-5]
		if hasattr(self.currentScene, func):
			try:
				getattr(self.currentScene, func)(event)
			except Exception, e:
				traceback()
		else:
			print "scene", self.currentScene, "does not handle", func, "events"
		
	def ConfigSave(self):
		return {}

	def Cleanup(self):
		self.frameListener.keepRendering = False
		self.frameListener.destroy()
		self.application.Exit()
		self.application.finder.remote.exit()

		while self.application.network.isAlive() or self.application.media.isAlive() or self.application.finder.isAlive():
			time.sleep(0.1)

	def changeScene(self, scene):
		"""Function to change to a different scene"""
		if hasattr(self, "currentScene"):
			self.hideScreen()
		self.currentScene = scene
		self.showScreen()

class Network(NetworkThread):
	## These are network events
	class NetworkFailureEvent(Exception):
		"""Raised when the network connection fails for what ever reason"""
		type = "NetworkFailure"

	def ConnectTo(self, host, username, password, debug=False):
		"""Connect to a given host using a certain username and password"""
		def callback(*args, **kw):
			#print "connect callback", args, kw
			gui.Call(gui.connectCallback, args, kw)

		gui = self.application.gui
		gui.Call(gui.hideScreen)
		try:
			if NetworkThread.ConnectTo(self, host, username, password, debug, callback):
				self.application.cache = Cache("tp://%s@%s:6923" % (username, host))
				self.CacheUpdate()
			else:
				gui.Call(gui.showScreen)
				gui.Call(gui.loadingFinished)
				gui.Call(gui.showMessage, "Problem with connecting to the server.\nPlease check your user id, password, server url and try again.")
		except AttributeError, e:
			print e
			gui.Call(gui.showScreen)
			gui.Call(gui.loadingFinished)
		except IOError, e:
			print e
			gui.Call(gui.showScreen)
			gui.Call(gui.loadingFinished)
	
	def CacheUpdate(self):
		"""Update the cache from the server"""
		def callback(*args, **kw):
			#print "update callback", args, kw
			gui.Call(gui.updateCallback, args, kw)
		
		gui = self.application.gui
		gui.Call(gui.hideScreen)
		NetworkThread.CacheUpdate(self, callback)
		gui.Call(gui.changeScene, gui.starmap)
		self.application.Post(self.application.cache.CacheUpdateEvent(None))
		gui.Call(gui.loadingFinished)
		return

class Application(ClientApplication):
	GUIClass = GUI
	NetworkClass = Network
	MediaClass = MediaThread
	FinderClass = FinderThread
	ConfigFile = "pyogre_preferences"

	def __init__(self, url=None):
		ClientApplication.__init__(self)
		self.url = url

if hasattr(sys, "frozen"):
	# capture stdout and stderr when in .exe mode
	sys.stdout = open("my_stdout.log", "w")
	sys.stderr = open("my_stderr.log", "w")

if __name__ == '__main__':
	try:
		url = name = passwd = None
		if len(sys.argv) > 1:
			url = sys.argv[1]

		app = Application(url)
		app.Run()
	finally:
		traceback()
		import threading
		while len(threading.enumerate()) != 1:
			time.sleep(0.1)
		sys.exit()

